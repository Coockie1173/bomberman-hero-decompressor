<html>
<head>
<meta charset="utf-8">
<title>SR64 Viewer</title>
</head>
<script src="three.min.js"></script>
<script src="pako.min.js"></script>
<body style="background: #111; color: #FFF;">

<div style="text-align: center;">
    <div>
        <div style="padding-bottom: 10px; text-align: left;"><input type="file" id="file"></div>
        <div style="display: inline-block; margin: auto auto; text-align: left;">
            <div id="container"></div>
        </div>
    </div>
</div>

<script>

const NUM_SR64_LEVELS = 13;

function Viewer(queryDomContainer)
{
    var _this = this;
    this.scene = new THREE.Scene();
    this.renderer = new THREE.WebGLRenderer({antialias: false});

    this.mapdv = null;
    this.raOtherArchives = 0;

    this.keysDown = {};

    this.camSpeedZ = 0;
    this.camSpeedX = 0;
    this.camSpeedY = 0;

    this.camRotSpeedX = 0;
    this.camRotSpeedY = 0;

    this.width = 960;
    this.height = 720;

    this.renderer.setPixelRatio(window.devicePixelRatio);
    this.renderer.setSize(this.width, this.height);
    this.renderer.setScissorTest(true);
    this.renderer.alpha = true;
    this.renderer.setClearColor(0, 1.0);
    this.renderer.setViewport(0, 0, this.width, this.height);
    this.renderer.setScissor(0, 0, this.width, this.height);

    this.renderer.domElement.tabIndex = '0'
    this.renderer.domElement.viewer = this;

    var domContainer = document.querySelector(queryDomContainer);
    var domSelectDiv = document.createElement('div');
    this.domSelect = document.createElement('select');

    this.domSelect.setAttribute('disabled', '')

    this.domSelect.addEventListener('change', function(e)
    {
        var levelIndex = this.value || 0;
        _this.loadMap(levelIndex);
    })

    for(var i = 0; i < NUM_SR64_LEVELS; i++)
    {
        var domOption = document.createElement('option');
        domOption.innerHTML = "Level 0" + i.toString(16).toUpperCase();
        domOption.setAttribute('value', i);
        this.domSelect.appendChild(domOption);
    }

    domSelectDiv.appendChild(this.domSelect);
    domContainer.appendChild(domSelectDiv);
    domContainer.appendChild(this.renderer.domElement);

    this.camera = new THREE.PerspectiveCamera(60, this.width/this.height, 1, 100000);
    this.camera.rotation.order = "YXZ";

    this.renderer.domElement.onkeydown = function(e)
    {
        this.viewer.keysDown[e.keyCode] = true;
    	e.preventDefault();
    	return false;
    }

    this.renderer.domElement.onkeyup = function(e)
    {
    	delete this.viewer.keysDown[e.keyCode];
    	e.preventDefault();
    	return false;
    }

    this.renderer.domElement.oncontextmenu = function(e)
    {
        e.preventDefault();
        return false;
    }

    this.renderer.domElement.onmousedown = function(e)
    {
        this.requestPointerLock();
        this.focus();
        e.preventDefault();
        return false;
    }

    var lastMovementX = 0;
    var lastMovementY = 0;

    this.renderer.domElement.onmousemove = function(e)
    {
        if(e.buttons == 0)
        {
            return;
        }

        var movementX = (lastMovementX*4 + e.movementX) / 5;
        var movementY = (lastMovementY*4 + e.movementY) / 5;
        lastMovementX = movementX;
        lastMovementY = movementY;

        if(e.buttons == 1)
        {
            viewer.camera.translateX(-movementX * 5);
            viewer.camera.translateY(movementY * 5);
        }

        if(e.buttons == 4)
        {
            viewer.camera.translateZ(-movementX * 5);
            viewer.camera.translateZ(movementY * 5);
        }

        if(e.buttons == 2)
        {
            //viewer.camRotSpeedX = -e.movementX * 20;
            viewer.camera.rotateY(-movementX * 0.01);
            viewer.camera.rotateX(-movementY * 0.01);
            viewer.camera.rotation.z = 0;
        }
    }

    this.renderer.domElement.onmouseup = function(e)
    {
        lastMovementX = 0;
        lastMovementY = 0;
        document.exitPointerLock();
    }

    this.keyEvents = {
	    //27: function(){ _this.resetCamera() }, // esc - reset camera position
	    87: function(viewer){ viewer.camSpeedZ = -30; }, // w - move forward
	    65: function(viewer){ viewer.camSpeedX = -30; }, // a - pan left
	    83: function(viewer){ viewer.camSpeedZ = 30; }, // s - move backward
	    68: function(viewer){ viewer.camSpeedX = 30; }, // d - pan right
	    90: function(viewer){ viewer.camSpeedY = -30; }, // z - move down
	    88: function(viewer){ viewer.camSpeedY = 30; }, // x - move up
	    40: function(viewer){ viewer.camRotSpeedX = -20; }, // down - rotate down
	    38: function(viewer){ viewer.camRotSpeedX =  20; }, // up - rotate up
	    37: function(viewer){ viewer.camRotSpeedY =  20;;}, // left - rotate left
	    39: function(viewer){ viewer.camRotSpeedY = -20;}  // right - rotate right
    }
}

Viewer.prototype.animate = function()
{
    viewer.camera.translateZ(this.camSpeedZ);
    viewer.camera.translateX(this.camSpeedX);
    viewer.camera.translateY(this.camSpeedY);

    viewer.camera.rotateX(this.camRotSpeedX / 1000);
    viewer.camera.rotateY(this.camRotSpeedY / 1000);
    viewer.camera.rotation.z = 0;

    if(this.camSpeedZ < 0) this.camSpeedZ += 0.25*3;
    if(this.camSpeedZ > 0) this.camSpeedZ -= 0.25*3;
    if(this.camSpeedX > 0) this.camSpeedX -= 0.25*3;
    if(this.camSpeedX < 0) this.camSpeedX += 0.25*3;
    if(this.camSpeedY > 0) this.camSpeedY -= 0.25*3;
    if(this.camSpeedY < 0) this.camSpeedY += 0.25*3;
    if(this.camRotSpeedX > 0) this.camRotSpeedX -= 1;
    if(this.camRotSpeedX < 0) this.camRotSpeedX += 1;
    if(this.camRotSpeedY > 0) this.camRotSpeedY -= 1;
    if(this.camRotSpeedY < 0) this.camRotSpeedY += 1;

    for(var k in this.keysDown)
    {
        if(k in this.keyEvents) this.keyEvents[k](this);
    }

    this.renderer.render(this.scene, this.camera)
    requestAnimationFrame(this.animate.bind(this));
}

Viewer.prototype.extractArchive = function(romOffset)
{
    var header = new ArchiveHeader(this.dv, romOffset);
    romOffset += ArchiveHeader.SIZE;

    var archiveDst = new Uint8Array(header.dstSize);
    var numBytesWritten = 0;

    while(numBytesWritten < header.dstSize)
    {
        var blockSrcSize = this.dv.getUint32(romOffset + 0x00);
        romOffset += 4;

        var blockSrc = this.ab.slice(romOffset, romOffset + blockSrcSize);
        var blockDst = pako.inflate(blockSrc);

        for(var i = 0; i < blockDst.byteLength; i++)
        {
            archiveDst[numBytesWritten + i] = blockDst[i];
        }

        romOffset += (blockSrcSize + 1) & 0xFFFFFFFE;
        numBytesWritten += blockDst.byteLength;
    }

    return archiveDst;
}

Viewer.prototype.loadArchiveGroup = function(numFiles, offsFileGroups, numFileGroups, offsFileTable, bVerbose)
{
    var files = [];
    var groups = [];

    for(var i = 0; i < numFiles; i++)
    {
        var offsEntry         = (offsFileTable + i * 12);
        var offsArchiveStart  = this.mapdv.getUint32(offsEntry + 0x00);
        var offsArchiveEnd    = this.mapdv.getUint32(offsEntry + 0x04);
        var offsMeta          = this.mapdv.getUint32(offsEntry + 0x08);
        var archiveRomAddr    = (this.raOtherArchives + offsArchiveStart);
        var archiveRomAddrEnd = (this.raOtherArchives + offsArchiveEnd);
        
        if(bVerbose)
        {
            console.log("extracted archive from " + (archiveRomAddr + 0x0C).toString(16));
        }

        var filedv = new DataView(this.extractArchive(archiveRomAddr).buffer);
        files.push({ dv: filedv, offsMeta: offsMeta });
    }

    for(var i = 0; i < numFileGroups; i++)
    {
        var fileIndices = [];

        var offsFileGroupHdr = this.mapdv.getUint32(offsFileGroups + i * 4);
        var numFileIndices   = this.mapdv.getUint32(offsFileGroupHdr + 0x00);
        var offsFileIndices  = this.mapdv.getUint32(offsFileGroupHdr + 0x04);

        for(var j = 0; j < numFileIndices; j++)
        {
            var fileIndex = this.mapdv.getUint16(offsFileIndices + j * 2);
            fileIndices.push(fileIndex);
        }

        groups.push(fileIndices);
    }

    return { files: files, groups: groups };
}

Viewer.prototype.loadMap = function(index)
{
    while(this.scene.children.length > 0)
    { 
        this.scene.remove(this.scene.children[0]); 
    }

    var raArchiveEntry = 0x000BBDA0 + index * 0x5C;
    var raArchive = this.dv.getUint32(raArchiveEntry + 0x14);
    //var raUnk = dv.getUint32(raArchiveEntry + 0x18);

    var archiveSrcSize = this.dv.getUint32(raArchive + 0x00);

    var raOtherArchives = raArchive + archiveSrcSize; // probably not the right way to obtain this
    this.raOtherArchives = raOtherArchives;

    var archiveDst = this.extractArchive(raArchive);
    var mapdv = new DataView(archiveDst.buffer);

    this.mapdv = mapdv;

    var offsEnd = mapdv.getUint32(0x000);
    
    var offsSphere          = mapdv.getUint32(0x00C)

//  var offsUnkFilePtrs     = mapdv.getUint32(0x048); // here for documentation purposes
    var numUnkFiles         = mapdv.getUint32(0x04C);
    var offsUnkFileGroups   = mapdv.getUint32(0x050);
    var numUnkFileGroups    = mapdv.getUint32(0x054);
    var offsUnkTable        = mapdv.getUint32(0x058);
//  var offsMeshFilePtrs    = mapdv.getUint32(0x05C)
    var numMeshFiles        = mapdv.getUint32(0x060);
    var offsMeshFileGroups  = mapdv.getUint32(0x064);
    var numMeshFileGroups   = mapdv.getUint32(0x068);
    var offsMeshTable       = mapdv.getUint32(0x06C);
    //                                        0x070 00000000
//  var offsUnk2FilePtrs    = mapdv.getUint32(0x074);
    var numUnk2Files        = mapdv.getUint32(0x078);
    var offsUnk2FileGroups  = mapdv.getUint32(0x07C);
    var numUnk2FileGroups   = mapdv.getUint32(0x080);
    //                                        0x084 00000000
    //                                        0x088 00000000
    var offsUnk2Table       = mapdv.getUint32(0x08C);
//  var offsPathFilePtrs0   = mapdv.getUint32(0x090);
    var numPathFiles0       = mapdv.getUint32(0x094);
    var offsPathFileGroups0 = mapdv.getUint32(0x098);
    var numPathFileGroups0  = mapdv.getUint32(0x09C);
    var unkA0               = mapdv.getUint32(0x0A0);
    var offsPathTable0      = mapdv.getUint32(0x0A4);
//  var offsPathFilePtrs1   = mapdv.getUint32(0x0A8);
    var numPathFiles1       = mapdv.getUint32(0x0AC);
    var offsPathFileGroups1 = mapdv.getUint32(0x0B0);
    var numPathFileGroups1  = mapdv.getUint32(0x0B4);
    var unkB8               = mapdv.getUint32(0x0B8);
    var offsPathTable1      = mapdv.getUint32(0x0BC);
//  var offsPathFilePtrs2   = mapdv.getUint32(0x0C0);
    var numPathFiles2       = mapdv.getUint32(0x0C4);
    var offsPathFileGroups2 = mapdv.getUint32(0x0C8);
    var numPathFileGroups2  = mapdv.getUint32(0x0CC);
    var unkD0               = mapdv.getUint32(0x0D0);
    var offsPathTable2      = mapdv.getUint32(0x0D4);
//  var offsPathFilePtrs2   = mapdv.getUint32(0x0D8);
    var numPathFiles3       = mapdv.getUint32(0x0DC);
    var offsPathFileGroups3 = mapdv.getUint32(0x0E0);
    var numPathFileGroups3  = mapdv.getUint32(0x0E4);
    var unkE8               = mapdv.getUint32(0x0E8);
    var offsPathTable3      = mapdv.getUint32(0x0EC);
//  var numUnkPathPtrs      = mapdv.getUint32(0x0F0);
    var numUnkPathFiles     = mapdv.getUint32(0x0F4);
    var offsUnkPathGroups   = mapdv.getUint32(0x0F8);
    var numUnkPathGroups    = mapdv.getUint32(0x0FC);
    var offsUnkPathTable    = mapdv.getUint32(0x100);
    //                                        0x104
    var offsTiltLines       = mapdv.getUint32(0x108);
    var numTiltLines        = mapdv.getUint32(0x10C);

    var offsSceneryObjects  = mapdv.getUint32(0x324);
    var numSceneryObjects   = mapdv.getUint32(0x328);

    var offsUnkGeom         = 0x334;

    var numCoinGroups       = mapdv.getUint16(0x3B0);
    var numSomething2       = mapdv.getUint16(0x3B4);
    var numBoosters         = mapdv.getUint16(0x3B8);
    var offsCoinGroups      = mapdv.getUint32(0x3C4);
    var offsSomething2      = mapdv.getUint32(0x3C8);
    //                                        0x3CC 00000000
    var offsBoosters        = mapdv.getUint32(0x3D0);

    var unkFiles = this.loadArchiveGroup(numUnkFiles, offsUnkFileGroups, numUnkFileGroups, offsUnkTable); // collision?
    var meshFiles = this.loadArchiveGroup(numMeshFiles, offsMeshFileGroups, numMeshFileGroups, offsMeshTable);
    var unk2Files = this.loadArchiveGroup(numUnk2Files, offsUnk2FileGroups, numUnk2FileGroups, offsUnk2Table);
    var pathFiles0 = this.loadArchiveGroup(numPathFiles0, offsPathFileGroups0, numPathFileGroups0, offsPathTable0);
    var pathFiles1 = this.loadArchiveGroup(numPathFiles1, offsPathFileGroups1, numPathFileGroups1, offsPathTable1);
    var pathFiles2 = this.loadArchiveGroup(numPathFiles2, offsPathFileGroups2, numPathFileGroups2, offsPathTable2);
    var pathFiles3 = this.loadArchiveGroup(numPathFiles3, offsPathFileGroups3, numPathFileGroups3, offsPathTable3);
    var unkPathFiles = this.loadArchiveGroup(numUnkPathFiles, offsUnkPathGroups, numUnkPathGroups, offsUnkPathTable);

    // note: pathFiles3 is empty for every level

    this.sceneAddUnknownSphere(offsSphere); // skydome? need to find translation values
    this.sceneAddTrackModel(meshFiles);
    this.sceneAddUnk2(unk2Files); // path
    this.sceneAddPath(pathFiles0, 0xFF0000);
    this.sceneAddPath(pathFiles1, 0x00FF00);
    this.sceneAddPath(pathFiles2, 0x0000FF);
    this.sceneAddPath(pathFiles3, 0xFF00FF);
    this.sceneAddTiltLines(offsTiltLines, numTiltLines);
    this.sceneAddCoinGroups(offsCoinGroups, numCoinGroups);
    this.sceneAddUnkPath(unkPathFiles); // another path type, doesn't seem to line up well with track model for some reason
    this.sceneAddObjects(offsSceneryObjects, numSceneryObjects);
    //this.sceneAddUnkGeom(offsUnkGeom);
    this.sceneAddBoosters(offsBoosters, numBoosters);
}

Number.prototype.hex = function(len)
{
    len = len || 8;
    var s = this.toString(16).toUpperCase();
    while(s.length < len) s = "0" + s;
    return s;
}

function debuglog(jsobj)
{
    var s = jsobj.constructor.name + " { ";
    var keys = Object.keys(jsobj);
    for(var i in keys)
    {
        if(i != 0) s += ", ";
        s += keys[i] + ": " + jsobj[keys[i]].hex();
    }
    s += " }";
    console.log(s);
}

Viewer.prototype.sceneAddObjects = function(offsSceneryObjects, numSceneryObjects)
{
    for(var nObject = 0; nObject < numSceneryObjects; nObject++)
    {
        var offset = offsSceneryObjects + (nObject * ObjectMeta.SIZE);
        var objectMeta = new ObjectMeta(this.mapdv, offset);
        var position = new Vec3f(this.mapdv, objectMeta.offsPosition);
        var geomMeta = new GeometryMeta(this.mapdv, objectMeta.offsGeomMeta);

        for(var numAnim = 0; numAnim < objectMeta.numAnimHeaders; numAnim++)
        {
            var offsAnimHeader = objectMeta.offsAnimHeaders + numAnim * AnimHeader.SIZE;
            var animHeader = new AnimHeader(this.mapdv, offsAnimHeader);
            //debuglog(animHeader);
        }

        var geom = new THREE.Geometry();

        for(var nVertex = 0; nVertex < geomMeta.numVertices; nVertex++)
        {
            var vertexOffset = geomMeta.offsVertices + (nVertex * Vec3s.SIZE);
            var vertex = new Vec3s(this.mapdv, vertexOffset);
            geom.vertices.push(new THREE.Vector3(-vertex.x, vertex.z, vertex.y));
        }

        for(var nFace = 0; nFace < geomMeta.numFaces; nFace++)
        {
            var offsFace = geomMeta.offsFaces + (nFace * MeshFace.SIZE);
            var face = new MeshFace(this.mapdv, offsFace);
            geom.faces.push(new THREE.Face3( face.vertexIndex0, face.vertexIndex1, face.vertexIndex2));

            if(face.vertexIndex3 != -1)
            {
                geom.faces.push(new THREE.Face3(face.vertexIndex0, face.vertexIndex2, face.vertexIndex3));
            }
        }

        var material = new THREE.MeshBasicMaterial({ color: 0x00ff00, wireframe: true });
        var mesh = new THREE.Mesh(geom, material);
        mesh.position.set(-position.x*32, position.z*32, position.y*32);
        this.scene.add(mesh);
    }
}

Viewer.prototype.sceneAddCoinGroups = function(offsCoinGroups, numCoinGroups)
{
    for(var nCoinGroup = 0; nCoinGroup < numCoinGroups; nCoinGroup++)
    {
        var geom = new THREE.Geometry();
        var boundingGeom = new THREE.Geometry();
        var pointsMaterial = new THREE.PointsMaterial({ color: 0xFF0000, size: 10, sizeAttenuation: false });
        var boundingPointsMaterial = new THREE.PointsMaterial({ color: 0xFF0000, size: 3, sizeAttenuation: false });

        var offsCoinGroup = offsCoinGroups + (nCoinGroup * 0x38);

        var numCoins   = this.mapdv.getUint8(offsCoinGroup + 0x00);
        var minpos     = new Vec3f(this.mapdv, offsCoinGroup + 0x0C);
        var maxpos     = new Vec3f(this.mapdv, offsCoinGroup + 0x18);
        var offsCoins  = this.mapdv.getUint32(offsCoinGroup + 0x24);

        boundingGeom.vertices.push(new THREE.Vector3(-minpos.x*32, minpos.z*32, minpos.y*32));
        boundingGeom.vertices.push(new THREE.Vector3(-maxpos.x*32, maxpos.z*32, maxpos.y*32));

        for(var nCoin = 0; nCoin < numCoins; nCoin++)
        {
            var offsCoin = offsCoins + (nCoin * 16);
            var coinPos = new Vec3f(this.mapdv, offsCoin + 0x00);
            geom.vertices.push(new THREE.Vector3(-coinPos.x*32, coinPos.z*32, coinPos.y*32));
        }

        var points = new THREE.Points(geom, pointsMaterial);
        var boundingPoints = new THREE.Points(boundingGeom, boundingPointsMaterial);
        var boundingBox = new THREE.BoxHelper(boundingPoints, 0xFFFF00);

        this.scene.add(points);
        this.scene.add(boundingPoints);
        this.scene.add(boundingBox);
    }
}

Viewer.prototype.sceneAddBoosters = function(offsBoosters, numBoosters)
{
    for(var nBooster = 0; nBooster < numBoosters; nBooster++)
    {
        var offsBooster = offsBoosters + (nBooster * 0x38);
        var count = this.mapdv.getUint8(offsBooster + 0x03);
        var offsListA = this.mapdv.getUint32(offsBooster + 0x30);
        var offsListB = this.mapdv.getUint32(offsBooster + 0x34);

        for(var nLine = 0; nLine < count; nLine++)
        {
            var offsetA = offsListA + (nLine * 12);
            var offsetB = offsListB + (nLine * 12);

            var posA = new Vec3f(this.mapdv, offsetA);
            var posB = new Vec3f(this.mapdv, offsetB);

            var geom = new THREE.Geometry();
            var lineMaterial = new THREE.LineBasicMaterial({ color: 0x00FFFF });
            var pointsMaterial = new THREE.PointsMaterial({ color: 0x00FFFF, size: 5, sizeAttenuation: false });
            geom.vertices.push(new THREE.Vector3(-posA.x*32, posA.z*32, posA.y*32))
            geom.vertices.push(new THREE.Vector3(-posB.x*32, posB.z*32, posB.y*32))
            var line = new THREE.Line(geom, lineMaterial);
            var points = new THREE.Points(geom, pointsMaterial);
            this.scene.add(line);
            this.scene.add(points);
        }
    }
}

Viewer.prototype.sceneAddUnk2 = function(fileGroup)
{
    for(var nGroup in fileGroup.groups)
    {
        var indices = fileGroup.groups[nGroup];
        for(var i in indices)
        {
            var index = indices[i];
            var file = fileGroup.files[index];
            
            var geom = new THREE.Geometry();
            var pointsMaterial = new THREE.PointsMaterial({ color: randColor24(100), size: 5, sizeAttenuation: false });

            var unk0C = file.dv.getFloat32(0x0C);
            var unk10 = file.dv.getFloat32(0x10);
            //console.log(unk0C, unk10);

            var count = file.dv.getUint32(0x08);
            for(var j = 0; j < count; j++)
            {
                var offset = 0x28 + j * 0x1C;
                var pos = new Vec3f(file.dv, offset);
                geom.vertices.push(new THREE.Vector3(-pos.x*32, pos.z*32, pos.y*32))
            }

            var points = new THREE.Points(geom, pointsMaterial);
            this.scene.add(points);
        }
    }

}

Viewer.prototype.sceneAddUnkGeom = function(offsUnkGeom)
{
    var geom = new THREE.Geometry();
    var pointsMaterial = new THREE.PointsMaterial({ color: 0x00FFFF, size: 10, sizeAttenuation: false });
    for(var i = 0; i < 8; i++)
    {
        var offset = offsUnkGeom + i * 12;
        var pos = new Vec3f(this.mapdv, offset);
        geom.vertices.push(new THREE.Vector3(-pos.x*32, pos.z*32, pos.y*32))
    }
    var points = new THREE.Points(geom, pointsMaterial);
    this.scene.add(points);
}

Viewer.prototype.sceneAddUnkPath = function(fileGroup)
{
    var lineMaterial = new THREE.LineBasicMaterial({ color: 0xFFFF00 });
    var pointsMaterial = new THREE.PointsMaterial({ color: 0xFFFF00, size: 5, sizeAttenuation: false });
    
    for(var nGroup in fileGroup.groups)
    {
        var indices = fileGroup.groups[nGroup];
        for(var i in indices)
        {
            var index = indices[i];
            var file = fileGroup.files[index];

            var count = file.dv.getUint32(0x00) + 1;
            var geom = new THREE.Geometry();

            for(var j = 0; j < count; j++)
            {
                var offset = j * 16;
                var pos = new Vec3f(file.dv, offset + 0x04);
                geom.vertices.push(new THREE.Vector3(-pos.x * 32, pos.z * 32, pos.y * 32))
            }
        
            var points = new THREE.Points(geom, pointsMaterial);
            var line = new THREE.Line(geom, lineMaterial);
            this.scene.add(points);
            this.scene.add(line);
        }
    }
}

Viewer.prototype.sceneAddTiltLines = function(offsTiltLines, numTiltLines)
{
    var lineMaterial = new THREE.LineBasicMaterial({color: 0x8888FF});
    var pointsMaterial = new THREE.PointsMaterial({ color: 0x8888FF, size: 5, sizeAttenuation: false });

    for(var nTiltLine = 0; nTiltLine < numTiltLines; nTiltLine++)
    {
        var offset = offsTiltLines + (nTiltLine * 0x2C);
        // todo 00, 04
        var posA = new Vec3f(this.mapdv, offset + 0x08);
        var posB = new Vec3f(this.mapdv, offset + 0x14);
        // todo 20, 24, 28

        var geom = new THREE.Geometry();
        geom.vertices.push(new THREE.Vector3(-posA.x * 32, posA.z * 32, posA.y * 32))
        geom.vertices.push(new THREE.Vector3(-posB.x * 32, posB.z * 32, posB.y * 32));

        var points = new THREE.Points(geom, pointsMaterial);
        var line = new THREE.Line(geom, pointsMaterial);

        this.scene.add(points);
        this.scene.add(line);
    }
}

Viewer.prototype.sceneAddUnknownSphere = function(offsUnk)
{
    var offsVertices = this.mapdv.getUint32(offsUnk + 0x00);
    var numVertices = this.mapdv.getUint32(offsUnk + 0x04);
    var offsFaces = this.mapdv.getUint32(offsUnk + 0x08);
    var numFaces = this.mapdv.getUint32(offsUnk + 0x0C);

    var geom = new THREE.Geometry();

    for(var nVertex = 0; nVertex < numVertices; nVertex++)
    {
        var offset = offsVertices + (nVertex * Vec3s.SIZE);
        var vertex = new Vec3s(this.mapdv, offset);

        geom.vertices.push(new THREE.Vector3(
            -vertex.x * 32,
            vertex.z * 32,
            vertex.y * 32));
    }

    for(var nFace = 0; nFace < numFaces; nFace++)
    {
        var offsFace = offsFaces + (nFace * MeshFace.SIZE);
        var face = new MeshFace(this.mapdv, offsFace);

        geom.faces.push(new THREE.Face3(face.vertexIndex0, face.vertexIndex1, face.vertexIndex2));

        if(face.vertexIndex3 != -1)
        {
            geom.faces.push(new THREE.Face3(face.vertexIndex0, face.vertexIndex2, face.vertexIndex3));
        }
    }

    var material = new THREE.MeshBasicMaterial({ color: 0xFFFFFF, wireframe: true });
    var mesh = new THREE.Mesh(geom, material);

    this.scene.add(mesh);
}

Viewer.prototype.sceneAddTrackModel = function(fileGroup)
{
    for(var nGroup in fileGroup.groups)
    {
        var indices = fileGroup.groups[nGroup];
        for(var i in indices)
        {
            var index = indices[i];
            var file = fileGroup.files[index];
            this.addMesh(file);
        }
    }
}

Viewer.prototype.addMesh = function(file)
{
    var geom = new THREE.Geometry();
    
    var meshMeta = new MeshMeta(file.dv, file.offsMeta);
    var geomMeta = new GeometryMeta(file.dv, meshMeta.offsGeomMeta);

    for(var nVertex = 0; nVertex < geomMeta.numVertices; nVertex++)
    {
        var offsVertex = geomMeta.offsVertices + (nVertex * Vec3s.SIZE);
        var vertex = new Vec3s(file.dv, offsVertex);
        var vec3 = new THREE.Vector3(
            (vertex.x + meshMeta.meshX) * -1.0,
            (vertex.z + meshMeta.meshZ),
            (vertex.y + meshMeta.meshY)
        );
        geom.vertices.push(vec3);
    }

    for(var nFace = 0; nFace < geomMeta.numFaces; nFace++)
    {
        var offsFace = geomMeta.offsFaces + (nFace * MeshFace.SIZE);
        var face = new MeshFace(file.dv, offsFace);
        geom.faces.push(new THREE.Face3(face.vertexIndex0, face.vertexIndex1, face.vertexIndex2));
        if(face.vertexIndex3 != -1)
        {
            geom.faces.push(new THREE.Face3(face.vertexIndex0, face.vertexIndex2, face.vertexIndex3));
        }
    }

    var mat = new THREE.MeshBasicMaterial({ color: 0xFFFFFF, wireframe: true, transparent: true, opacity: 0.3 });
    var obj = new THREE.Mesh(geom, mat);
    this.scene.add(obj);
}

Viewer.prototype.sceneAddPath = function(fileGroup, color)
{
    var geom = new THREE.Geometry();
    var lineMaterial = new THREE.LineBasicMaterial({color: color});
    var pointsMaterial = new THREE.PointsMaterial({ color: color, size: 3, sizeAttenuation: false });

    // only group 0 seems to be used
    for(var nGroup in fileGroup.groups)
    {
        var indices = fileGroup.groups[nGroup];

        for(var i in indices)
        {
            var index = indices[i];
            var file = fileGroup.files[index];

            var numPoints = file.dv.getUint32(0x08);

            for(var nPoint = 0; nPoint < numPoints; nPoint++)
            {
                var offset = 0x18 + (nPoint * Vec3f.SIZE);
                var pos = new Vec3f(file.dv, offset);
                geom.vertices.push(new THREE.Vector3(-pos.x * 32, pos.z * 32, pos.y * 32));
            }
        }
    }

    var pointField = new THREE.Points(geom, pointsMaterial);
    var line = new THREE.Line(geom, lineMaterial);

    this.scene.add(pointField);
    this.scene.add(line);
}

Viewer.prototype.loadRom = function(ab)
{
    this.ab = ab;
    this.dv = new DataView(ab);
    this.loadMap(0);
    this.domSelect.removeAttribute('disabled');
}

function ArchiveHeader(dv, offset)
{
    this.srcSize = dv.getUint32(offset + 0x00);
    this.dstSize = dv.getUint32(offset + 0x04);
}

ArchiveHeader.SIZE = 8;

function ObjectMeta(dv, offset)
{
    this.offsGeomMeta    = dv.getUint32(offset + 0x00);
    this.unk04           = dv.getUint32(offset + 0x04);
    this.unk08           = dv.getUint32(offset + 0x08);
    this.unk0C           = dv.getUint32(offset + 0x0C);
    this.offsPosition    = dv.getUint32(offset + 0x10);
    this.offsAnimHeaders = dv.getUint32(offset + 0x14);
    this.numAnimHeaders  = dv.getUint32(offset + 0x18);
    this.unk1C           = dv.getUint32(offset + 0x1C);
    this.unk20           = dv.getUint32(offset + 0x20);
    this.unk24           = dv.getUint32(offset + 0x24);
}
ObjectMeta.SIZE = 0x28;

function AnimHeader(dv, offset)
{
    this.flags00   = dv.getUint32(offset + 0x00);
    this.unk04     = dv.getUint32(offset + 0x04);
    this.unk08     = dv.getFloat32(offset + 0x08);
    this.unk0C     = dv.getFloat32(offset + 0x0C);
    this.flags10   = dv.getUint32(offset + 0x10);
    this.offsUnk14 = dv.getUint32(offset + 0x14);
    this.offsUnk18 = dv.getUint32(offset + 0x18);
    this.offsUnk1C = dv.getUint32(offset + 0x1C);
}
AnimHeader.SIZE = 0x20;

function MeshMeta(dv, offset)
{
    this.unk00        = dv.getUint32(offset + 0x00);
    this.unk04        = dv.getUint32(offset + 0x04);
    this.offsGeomMeta = dv.getUint32(offset + 0x08);
    this.meshX        = (dv.getInt32(offset + 0x0C) / 2048);
    this.meshY        = (dv.getInt32(offset + 0x10) / 2048);
    this.meshZ        = (dv.getInt32(offset + 0x14) / 2048);
    this.unk18        = dv.getUint32(offset + 0x18);
    this.unk1C        = dv.getUint32(offset + 0x1C);
    this.unk20        = dv.getUint32(offset + 0x20);
    this.unk24        = dv.getUint32(offset + 0x24);
}

function GeometryMeta(dv, offset)
{
    this.offsVertices = dv.getUint32(offset + 0x00);
    this.numVertices  = dv.getUint32(offset + 0x04);
    this.offsFaces    = dv.getUint32(offset + 0x08);
    this.numFaces     = dv.getUint32(offset + 0x0C);
    this.offsTexCoords = dv.getUint32(offset + 0x10);
    this.numTexCoords  = dv.getUint32(offset + 0x14);
    this.offsColors    = dv.getUint32(offset + 0x18);
    this.numColors     = dv.getUint32(offset + 0x1C);
}

function Vec3s(dv, offset)
{
    this.x = dv.getInt16(offset + 0x00);
    this.y = dv.getInt16(offset + 0x02);
    this.z = dv.getInt16(offset + 0x04);
}
Vec3s.SIZE = 0x06;

function Vec3f(dv, offset)
{
    this.x = dv.getFloat32(offset + 0x00);
    this.y = dv.getFloat32(offset + 0x04);
    this.z = dv.getFloat32(offset + 0x08);
}
Vec3f.SIZE = 0x0C;

function MeshFace(dv, offset)
{
    this.unk00 = dv.getUint16(offset + 0x00);
    this.unk02 = dv.getUint16(offset + 0x02); // if((unk02 & *(u32*)(0x800A920C)) != 0) don't draw
    this.materialIndex = dv.getUint8(offset + 0x04);
    // 05, 06, 07 padding
    this.vertexIndex0   = dv.getInt16(offset + 0x08);
    this.vertexIndex1   = dv.getInt16(offset + 0x0A);
    this.vertexIndex2   = dv.getInt16(offset + 0x0C);
    this.vertexIndex3   = dv.getInt16(offset + 0x0E);
    this.texCoordIndex0 = dv.getInt16(offset + 0x10);
    this.texCoordIndex1 = dv.getInt16(offset + 0x12);
    this.texCoordIndex2 = dv.getInt16(offset + 0x14);
    this.texCoordIndex3 = dv.getInt16(offset + 0x16);
    this.colorIndex0    = dv.getInt16(offset + 0x18);
    this.colorIndex1    = dv.getInt16(offset + 0x1A);
    this.colorIndex2    = dv.getInt16(offset + 0x1C);
    this.colorIndex3    = dv.getInt16(offset + 0x1E);
}

MeshFace.SIZE = 0x20;

function randColor24(minGamma)
{
    var t = 255 - minGamma;
    var r = (minGamma + Math.random() * t) & 0xFF;
    var g = (minGamma + Math.random() * t) & 0xFF;
    var b = (minGamma + Math.random() * t) & 0xFF;
    return (r << 16 | g << 8 | b);
}

//////////////////////////////////////////////////

function attachFileReader(query, onloadend)
{
    var domFileInput = document.querySelector(query);
    var reader = new FileReader();
    reader.onloadend = function()
    {
        onloadend(reader.result);
    }

    domFileInput.addEventListener('change', function()
    {
        reader.readAsArrayBuffer(domFileInput.files[0]);
    });
}

attachFileReader('#file', function(ab)
{
    viewer.loadRom(ab);
})


var viewer = new Viewer('#container');
viewer.animate();

</script>
</body>
</html>
